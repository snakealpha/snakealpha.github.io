---
layout: post
title: Unity3D 图形性能优化

tag: [译文, 图形]
categories: [Unity3D]

by-nc: true
---

<small>本文为Unity3D官方文档[Optimizing Graphics Performance](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)的中文翻译。在这篇文章中，Unity官方提到了很多优化方面的方向性思路，是一篇具有指导性意义的文献。</small>

对于一款游戏的成功来说，好的性能总是至关重要。本文中包含了一些能够有效提升你的游戏性能的指导原则。

## 图形性能被耗在哪里？

你游戏中的图形部分主要会消耗两种系统资源：GPU和CPU。然而，由于针对GPU与CPU的优化策略大相径庭（甚至完全相反——为了优化CPU性能，你往往需要让GPU承担更多工作，反之亦然），对于任何优化行动，至关重要的第一步总是**定位性能问题的发生点**。

典型的性能瓶颈以及它们的判断方法包括：

- GPU往往受制于**填充率**和内存带宽。

- - 当你的游戏运行于较低的显示分辨率时，它是不是会跑的更快？如果是，你极有可能是受到了GPU填充率的制约。

- CPU准备渲染的过程（也就是**draw call**）常常限制性能。

- - 通过[Rendering Statistics](http://docs.unity3d.com/Manual/RenderingStatistics.html)窗口检查draw calls的数量；如果这个数字达到好几千（PC平台）抑或是好几百（移动平台），你就得优化一下对象的数量了。

当然，这只是一些概略的规则；其他地方也有可能出现瓶颈。一些不太常见的性能瓶颈还包括：

- 无论是对于CPU还是GPU，渲染本身都不是问题——你的代码和物理运算部分可能才是真正的问题所在。使用[Profiler](http://docs.unity3d.com/Manual/Profiler.html)分析代码，以找出问题所在。

- GPU需要处理太多的顶点。GPU处理顶点的能力取决于GPU本身的本身的素质以及顶点着色器的复杂程度。这方面常见的指导原则包括移动游戏**不要超过100k个定点**以及PC游戏**不要达到几M个顶点**。

- 有一些功能需要依赖CPU处理顶点，因此CPU需要处理的顶点过多也可能成为瓶颈。skinned mesh，布料模拟和粒子系统都需要依赖于CPU。

## CPU优化——抑制draw call

为了在屏幕上渲染物体，CPU也有一些工作要做，比如说确定影响物体的光源，设置着色器以及着色器参数，以及准备和发送绘图命令到图形驱动。CPU需要为**每个物体**完成这些工作，这并不轻松。要是你偏偏有很多可视的物体需要处理...那就更惨了。

因此，比如当你有几千个三角形需要处理的时候，相比于分别处理几千个各自只包含了一个三角形的网格，一次处理拥有几千个三角形的网格要高效得多。虽然对于GPU来说这两种情况基本是一回事，对CPU来说处理几千个物体的花销可就相当可观了。

为了减轻CPU的工作负担，减少可见物体的数量总是个好办法。比如做这些事试试：

- 将不会变动的物体合并。你可以手工去做，也可以借助Unity的[draw call batching](http://docs.unity3d.com/Manual/DrawCallBatching.html)功能。

- 在你的物体上使用尽量少种类的材质。通过把独立的贴图放到一个较大的贴图atlas里面，就可以做到这一点。

- 尽量少使用会导致物体渲染多次的功能（比如反射，阴影，每像素光照等。详见下文。）

可以通过合并物体使至少几百个三角形形成只使用一种**材质**的网格。务必记得合并两个并未共享同一材质的对象并不能使性能有所提升。最常见的多个物体不共享同一材质的原因在于，这些网格并没有使用相同的纹理。在这种情况下，要实现优化CPU性能的目的，你得确保你合并的所有网格使用了相同的纹理。

在[Forward渲染路径](http://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html)中，如果使用多个像素光源，合并对象有可能没啥效果。下文会对此做出解释。

## GPU：几何建模优化

当试图优化一个模型的几何结构时，有两个基本原则：

- 不要使用多于必要的三角形。

- 尽量减少uv映射焊接和硬边缘（会消耗两倍的顶点数）的数量。

注意，图形硬件实际上需要处理的顶点数往往与3D应用汇报的数字不同。建模软件显示的通常只是几何上的顶点数。而对于显卡来说，一些结合顶点需要被分割成多个逻辑上的顶点才能完成渲染。如果一个顶点拥有多个法线，UV坐标或者顶点色参数，这个顶点就必须被拆分了。因此，Unity中显示的顶点数基本上会高于3D软件中给出的顶点数。

模型中的几何体大多是由CPU处理的，但是Unity中的一些功能需要使用CPU处理模型，比如网格皮肤。

## 光照性能

无需计算的光照是最快的！使用[光照贴图](http://docs.unity3d.com/Manual/Lightmapping.html)来"烘焙"静态光源的过程只需要进行一次，就能在每一帧里替代光照处理的计算。在Unity中生成一个光照贴图的工作只比单单将一个光源放到场景中麻烦一点点，**但是：**

- 这样程序能跑得快得多（在有两个像素光源的情况下，能快上2-3倍）

- 看上去效果也会更好——你可以烘焙全局光照，而烘焙工具会帮你平滑结果。

有很多简单的方法可以伪造出布设光源才能取得的效果（比如通过着色器，或是定制资源本身）。举例来说，如果需要轮廓照明的效果，可以不用真的添加一个直射摄像机的光源，只要直接在你的着色器里加上专用的"rim lighting"计算即可。

### Forward渲染路径下的光照

每像素动态光照会显著增大受其影响的每个像素的渲染负担，并且需要对每个物体使用多个pass。在性能较低的图形设备比如移动设备或者低端的PC GPU上，尽量不要出现超过一个受到每像素光照的光源影响的物体，并对静态物体使用光照贴图，而不是使用动态光源每帧计算光照。每顶点动态光照会增加顶点变换所需要的花销。应当努力避免有物体同时受到多个光源照射的情况。

如果你使用像素光源，则你的网格背多少像素光源照到，光照就得被渲染多少次。如果你连接了两个离得相当远的网格，则整个连接后的对象都会受到影响。所有像素光源无论照射到这个物体的哪个部分，都会在渲染时产生影响，因此需要进行的渲染pass数量也会增大。理想情况下，连接后的物体必须被渲染的pass数目是物体连接之前需要的pass之和，而连接不造成什么损失。为了达成这一点，你需要避免连接那些离得远到被不同像素光源照到的物体。

渲染时，Unity会寻找一个网格周边的所有光源，并从中找到对网格影响最大的光源。[Quality Settings](http://docs.unity3d.com/Manual/class-QualitySettings.html)可用于修改光源中像素光源和顶点光源各自的数量。每个光源会依据它离网格的距离以及光线强度算出其重要性。尽管如此，总会有一些光源设计上就比其他光源来得重要。在这种情况下，修改光源的*Render Mode*属性为*Important*或者*Not Important*；被指定为*Not Important*的光源一定会使用较低花销的方法来渲染。

作为一个例子，想象一下在一个赛车游戏中，玩家开着车的前灯在黑夜中驾驶。车的前灯显然是游戏中所有可见光源里最明亮的，因此他们的Render Mode应该被设为Important。另一方面，游戏中的其他光源相比之下重要性较弱（比如前车的尾灯），因此不需要使用像素光源来保证其显示效果。这些光源的Render Mode就可以设置为Not Important来避免浪费渲染性能。

优化每像素光照对CPU和GPU都有好处：CPU可以产生较少的draw call，GPU可以处理更少的顶点，亦能在光栅化的过程里为这些物体处理更少的像素。

## GPU优化：纹理压缩和Mipmap

使用[压缩纹理](http://docs.unity3d.com/Manual/class-TextureImporter.html)将有效减小你的纹理尺寸（并带来更快的加载速度和更小的内存消耗），同时亦能够有效提升渲染性能。相比于未压缩的32bit ARGB格式纹理，压缩后的纹理只会使用一小部分内存带宽。

## 使用Mipmap

粗略的说，在3D场景中应当一直保持[生成Mipmap](http://docs.unity3d.com/Manual/class-TextureImporter.html)选项的开启。出于和纹理压缩能够在GPU渲染过程中帮助减小传输到GPU的纹理数据的尺寸相同的目的，启用mipmap的纹理能够在较小的三角形上使用较低分辨率的纹理。

这一规则的唯一例外就是当已经确定纹理中的图素和屏幕像素是1：1对应的情况，这种情况会在UI元素和2D游戏中出现。

## LOD和每层剔除距离

在一些游戏中，为了减小CPU与GPU的负担，可以剔除一些小的活动物体。举例来说，可以在一个比较远的距离上剔除小石子和岩屑，而依然保证同样距离的大楼可见。

这可以通过[细节等级](http://docs.unity3d.com/Manual/LevelOfDetail.html)系统实现，也能借助于在摄像机上手工设置每层的剔除距离。你可以把较小的物体摆到[独立的层](http://docs.unity3d.com/Manual/Layers.html)上，再使用[Camera.layerCullDistances](http://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html)方法设置该层的剔除距离。

## 实时阴影

实时阴影很炫，但是对性能也有重大影响，既有额外的Drawcall消耗CPU的性能，有需要GPU做出额外处理。要获得进一步细节，请参考[阴影](http://docs.unity3d.com/Manual/Shadows.html)。

## GPU优化：关于编写高性能着色器的建议

一个PC的高端GPU和一个移动平台的低端GPU之间可能足有几百倍的性能差距。即便同在一个平台上，还是会有类似情况：较快的GPU比较慢的集成GPU快上若干倍；而移动平台上不同档次GPU之间的差距也与此类似。

所以，无比时刻牢记移动平台或是低端电脑上的GPU会比你的开发机慢得多。通常，着色器都会需要手工优化来减小运算量和纹理读取操作，以此换得较好的性能。举例来说，Unity内置着色器往往都有它们的"mobile"等效版本，运行的比原版快得多（但是当然会有着很多限制和局限性，因此才会比较快）。

下面有一些对于移动平台和低端显卡较为重要的指导原则：

### 复杂数学操作

要实现复杂的数学函数（比如pow, exp, log, cos, sin, tan等等）得付出昂贵的代价，因此一个大略的指导原则是不要在每个像素操作中出现一个以上这类操作。如果有必要，考虑使用处理过的纹理代替着色器实现效果。

不要实现你自己的normalize，dot，inversesqt操作。内建的版本会生成更好的代码，充分利用GPU内建的功能而不是凭蛮力计算。

始终牢记可见性检测会拖慢片段着色器的处理速度。

### 浮点数操作

在编写自定义的着色器时你应当始终明确指定浮点数变量的精度。为了获得最优的性能，必须**严格确保浮点数保持能够满足需要的最小精度**。对于很多台式机GPU来说，这点确实无关紧要，但是对于移动平台GPU来说这十分重要。

如果着色器使用Cg/HLSL写就，时刻牢记下面这些内容：

 - float 完整的32位浮点数，适用于顶点变换的情景，最慢；
 - half 半精度的16位浮点数，适用于纹理UV坐标，性能是float的两倍；
 - fixed 10位顶点格式，使用于颜色，光照计算以及其他高性能操作，性能是float的4倍。

如果着色器使用GLSL ES写成，那么浮点精度由highp，mediump，lowp指定。

要获得更多关于着色器性能的建议，请移步[着色器性能](http://docs.unity3d.com/Manual/SL-ShaderPerformance.html)。

## 改善游戏性能的CheckList

 - 若定位于PC端，根据目标GPU的不同保持顶点数在每帧200K到3M个之间；
 - 如果要是用内建着色器，尽量使用Mobile和Unlit的版本。它们同样可以工作在非移动平台上，是更复杂版本的简化版；
 - 在每个场景中保持尽量少的不同材质——尽可能在不同物体之间共享材质；
 - 勾选静止物体的**static**选项来启用[静态批处理](http://docs.unity3d.com/Manual/DrawCallBatching.html)之类的内部优化；
 - 如果没有必要就不要使用**像素光源**——只使用一个像素光源（并且最好是方向光源）照射你的几何体；
 - 如果没有必要不要使用动态光源——用烘焙来替代；
 - 只要可能就使用压缩纹理，就算不行也尽量使用16位色而非32位色；
 - 没必要就不要使用雾化；
 - 学习和使用[封闭剔除](http://docs.unity3d.com/Manual/OcclusionCulling.html)功能来减少有大量不可见元素的复杂静态场景中不可见的集合体数量以及因此产生的多余drawcall。依据封闭剔除特性规划你的关卡；
 - 使用天空盒制作假的远方物体；
 - 使用像素着色器或纹理包含来混合多种纹理，避免使用多个pass的方式；
 - 写自定义的着色器时，牢记以下的浮点数类型：
  - fixed/lowp 用于颜色，光线信息和法线
  - half/mediump 用于纹理UV坐标；
  - float/highp 避免在像素着色器中使用，尽量只用于顶点着色器的坐标位置计算
 - 在像素着色器中尽量少用诸如pow,sin,cos这样的复杂数学操作符；
 - 每个片段尽量少用纹理。